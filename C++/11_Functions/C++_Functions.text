--------C++ Functions------------
What is a function?
    .C++ Programs:
        -C++ Standard Libraries (functions and classes)
        -3rd-Party Libraries (functions and classes)
        -Out own functions and classes

.Functions allow the modularization of a program
    -Separate code into logical self-contained units
    -These units can be reused

.Write your code to the function specification
.Understand what the function does
.Understand what information the function needs 
.Understand what the function returns
.Understand any errors the function may produce
.Understand any performance contraints

Information-Hiding: Don't worry about HOW the function works internally, unless you are the one
writing the function!

example:

int main(){

// read input
    read_input();

// process input
    process_input();

// provide output 
    provide_output();

    return 0;
}

.Common mathematical calculations
.Global functions called as:

function_name(argument);
    function_name(argument1, argument2, ...);

cout << sqrt(400.0) << endl;
double result;
result = pow(2.0, 3.0);
----------------------------------------------------------------------------------------
Defining our own functions:

int add_numbers(int a, int b){
    if (a < 0 || b < 0){
        return 0;
    }
    else {
        return a + b;
    }
}
cout << add_numbers(20, 40);

.Function Name:
    -the name of the function
    -same rules as for variables
    -should be meaningful!
    -usually a verb or verb phrase 

.Parameter List:
    -the variables that are expected to be passed into the function
    -their types must be specified

.Return Type:
    -the type of the data that is returned from the function
    -can return nothing, indicated with keyword 'VOID'

.Body:
    -the statements that are executed when the function is called 
    -enclosed in {} curly braces
---------------------
Examples:

int function_name(){
    statements(s);
    return 0;
}
---------------------
int function_name(int a){     // [return type] [function name] (parameters) 
    statement(s);             // [function body]
    return 0;
}
---------------------
No return type:

void function_name(){
    statement(s);
    return;                   // return statement is optional here
}
---------------------
void function_name(int a, std::string b){
    statement(s);             // arguments must be supplied in the order listed
    return; 
}
---------------------
void say_hello(){
    cout << "Hello" << endl;
}

int main(){
    for (size_t i{0}; i < 10; i++){
        say_hello();
    }
    return 0;
}
---------------------
.Functions can call other functions, however, the compiler
must know the function details BEFORE it is called!

int main(){
    say_hello(); // called BEFORE it is defined - ERROR
    return 0;
}
void say_hello(){
    cout << "Hello" << endl;
}
----------------------------------------------------------------------------------------
C++ Function Prototypes:

.The compiler must know about a function before it is used
.Define functions before calling them:
    -OK for small programs
    -Not a practical solution for larger programs
.Use function prototypes:
    -Tells the compiler what it needs to know without a full function definition 
    -Also called forward declarations
    -Placed at the beginning of the program
    -Also used in our own header files (.h)
----------------------------------
int function_name(); // prototype
int function_name(){
    statement(s);
    return 0;
}

int function_name(int);
int function_name(int a);

void function_name();

void function_name(int a, std::string b);
void function_name(int, std::string);
----------------------------------
EXAMPLE:

void say_hello();
void say_world();

int main(){
    say_hello();
    cout << " Bye from main" << endl;
    return 0;
}

void say_world(){
    cout << " World" << endl;
    cout << " Bye from say_world" << endl;
}

void say_hello(){
    cout << "Hello" << endl;
    say_world();
    cout << " Bye from say_hello" << endl; 
}
---------------------------------------------------------------------------------------
Function Parameters and pass-by-value:
.when we call a function we can pass in data to that function
.in the function call they are known as arguments
.in the function definition they are known as parameters
.they must match in number, order and in type

int add_numbers(int, int); // prototype

int main(){
    int result{0};
    result = add_numbers(100, 200); // function call
    return 0;
}

int add_numbers(int a, int b){      // function definition
    return a + b;
}


Pass-by-value:
.when you pass data into a function it is passed-by-value
.a copy of the data is passed to the function
.whatever changes you make to the parameter in the function does NOT
affect the argument that was passed in. 

.Formal vs Actual parameters:
    -Formal parameters: the parameters defined in the function header
    -Actual parameters: the arguments used within the function call 

examples:

void param_test(int formal){
    cout << formal << endl;
    formal = 100;
    cout << formal << endl;
}

int main(){
    int actual{50};
    cout << actual << endl;
    param_test(actual);
    cout << actual << endl;
    return 0;
}
---------------------------------------------------------------------------------------
Return Statement:

.If a function returns a value then it must use a return statement that returns the val
.If a function does not return a value (void), the return statement is optional
.RETURN statement can occur anywhere in the body of the function
.RETURN statement immediately exits the function
.We can have multiple return statements in function, but this is good to avoid.
.The return value is the result of the function call 
---------------------------------------------------------------------------------------
Default Parameter Values:

.When a function is called, all arguments must be supplied
.Sometimes, some of the arguments have the same values much of the time
.We can tell the compiler to use default values if the arguments are not supplied
*** .Default values can be in the prototype or definition, not both ***
    -Best practice is to set the default values within the prototype
    -Must appear at the tail end of the parameter list
.Can have multiple default values
    -Must appear consecutively at the tail end of the parameter list

examples:

double calc_cost(double base_cost, double tax_rate);

double calc_cost(double base_cost, double tax_rate){
    return base_cost += (base_cost * tax_rate);
}
                                      // No default arguments
int main(){
    double cost{0};
    cost = calc_cost(100.0, 0.06);
    return 0;
}
---------------------------------------------------------
double calc_cost(double base_cost, double tax_rate = 0.06);

double calc_cost(double base_cost, double tax_rate){
    return base_cost += (base_cost * tax_rate);
}
                                      // No default arguments
int main(){
    double cost{0};
    cost = calc_cost(200.0);          // Utilizes default tax_rate value
    cost = calc_cost(100.0, 0.08);    // Accepts custom tax_rate value
    return 0;
}
---------------------------------------------------------------------------------------
Function Overloading:

.We can have functions with different parameter lists that have the same name
.This is an abstraction mechanism since we can just think 'print', for example
.This is a type of polymorphism
    -We can have the same name work with different data types to execute similar 
    behavior
.The compiler must be able to tell the functions apart based on the parameter 
lists and arguments supplied

.Be careful not to use conflicting default parameters, will cause errors w/ overloading
------------------------------------------
int add_numbers(int, int);
double add_numbers(double, double);

int main(){
    cout << add_numbers(10,20) << endl;
    cout << add_numbers(10.0,20.0) << endl;
  return 0;
}

int add_numbers(int a, int b){
    return a + b;
}
int add_numbers(double a, double b){
    return a + b;
}
------------------------------------------
int get_value();
double get_value();           // This will produce an error since the compiler cannot
                              // distinguish between the 2 versions of get_value 
cout << get_value() << endl; 
---------------------------------------------------------------------------------------
Passing Arrays to Functions

.We can pass an array to a function by providing square brackets in the formal
parameter description
    void print_array(int numbers []);
.The array element are NOT copied
.Since the array name evaluates to the location of the array in memory, this address
is the piece of data that is copied
.The function has no idea how many elements are in the array since all it knows is 
the location of the first element in the array (array name)
------------------------------------
void print_array(int numbers[]);

int main(){
    int my_numbers[] {1,2,3,4,5};               // This version does not work!
    print_array(my_numbers);
    return 0;
}

void print_array(int numbers[]){
    // The function has no way of knowing how many elements to iterate over!
    // We need to pass in the size of the array in addition to the name
}
------------------------------------- ***************
void print_array(int numbers[], size_t size);

int main(){
    int my_numbers[] {1,2,3,4,5};               
    print_array(my_numbers, 5);            // NOTE: You CAN mutate original array
    return 0;
}

void print_array(int numbers[], size_t size){
    for (size_t i{0}; i < size; i++){
        cout << numbers[i] << endl;
    }
}
---------------------------------------
.We can tell the compiler that function parameters are const (read-only)
.This can be useful in the print_array function since it should NOT modify the array

void print_array(const int numbers[], size_t size){
    for (size_t i{0}; i < size; i++){
        cout << numbers[i] << endl;
    }
    numbers[i] = 0;       // This will result in a compiler error sinze numbers  
}                         // has been designated as a constant






.pass-by-reference
.inline functions
.auto return type
.recursive functions
