----------------------------------Smart Pointers---------------------------------------
Issues with Raw Pointers:

.C++ provides absolute flexibility with memory management
    -Allocation
    -Deallocation
    -Lifetime management
.Some potentially serious problems include:
    -Uninitialized (wild) pointers   // point to anywhere in memory, unintended
    -Memory leaks                    // not deallocated
    -Dangling pointers               // points to area that has been deallocated
    -Not exception safe              // compiler can throw errors
.Ownership?
    -Who owns the pointer?
    -When should a pointer be deleted?
----------------------------------------------------------------------------------------
What are Smart Pointers?

.Objects
.Can only point to heap-allocated memory
.Automatically call delete when no longer needed
.Adhere to RAII principles
.C++ Smart Pointers:
    -Unique Pointers (unique_ptr)
    -Shared Pointers (shared_ptr)
    -Weak Pointers   (weak_ptr)
    -Auto Pointers   // deprecated, (auto_ptr)

#include <memory>

.Smart pointers are defined by class templates:
    -Wrapper around a raw pointer
    -Overloaded operators 
        -Dereference(*)
        -Member selection(->)
        -Pointer arithmetic not supported (++,--,etc)
    -Can have custom deleters 
-----------------------------
{
    std::type_ptr<Some_Class> ptr = ...
    ptr->method();                // smart pointer ptr will automatically be 
    cout << (*ptr) << endl;       // deleted when no longer needed 
} 
-----------------------------
RAII - Resource Acquisition Is Initialization

.Common idiom or pattern used in software design based on container object lifetime
.RAII objects are allocated on the stack 
.Resource Acquisition:
    -Open a file, allocate memory, acquire a lock, etc.
.Is Initialization:
    -The resource is acquired within the constructor
.Resource Relinquishing:
    -Happens in the destructor
        .Close the file, deallocate the memory, release the lock, etc.

.Smart Pointers are an example of an RAII class 
----------------------------------------------------------------------------------------
Unique Pointer (unique_ptr)

.This is a simple type of smart pointer, very efficient!

unique_ptr<T>
    .Points to an object of type T on the heap
    .It is unique - there can only be one unique_ptr<T> pointing to this specific
    object on the heap
    .Owns what it points to
    .Cannot be assigned or copied
    .CAN be moved
    .When the pointer is destroyed, what it points to is automatically destroyed

{
    std::unique_ptr<int> p1 {new int{100} };
    std::cout << *p1 << std::endl;              // 100
    *p1 = 200;
    std::cout << *p1 << std::endl;              // 200
} // p1 is automatically deleted 

useful methods:

{
    std::unique_ptr<int> p1 {new int{100} };
    std::cout << p1.get() << std::endl;          // 0x564388, useful with raw ptr libs 
    p1.reset();                                  // p1 is now nullptr
                  so:
    if (p1) { std::cout << *p1 << std::endl; }   // won't execute
}                                           
-----------------------
{
    std::unique_ptr<Account> p1 {new Account{"Larry"}};
    std::cout << *p1 << std::endl;   // display account 
    p1->deposit(1000);
    p1->withdraw(500);
}
------------------------
{
    std::vector<std::unique_ptr<int>> vec;
    std::unique_ptr<int> ptr{new int{100}};
    vec.push_back(ptr);                     // Error, copy not allowed
    vec.push_back(std::move(ptr));          // Fine
}
------------------------
{
    std::unique_ptr<int> p1 = make_unique<int>(100);
    std::unique_ptr<Account> p2 = make_unique<Account>("Curly", 5000);
    auto p3 = make_unique<Player>("Hero", 100, 75);
}
----------------------------------------------------------------------------------------



.C++ Smart Pointers
    -Unique pointers (unique_ptr)
    -Shared pointers (shared_ptr)
    -Weak pointers (weak_ptr)
.Custom deleters
