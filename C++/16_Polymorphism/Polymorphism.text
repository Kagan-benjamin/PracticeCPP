--------------------------- Polymorphism -------------------------------------
What is polymorphism?

.Fundamental to Object-Oriented Programming
.Polymorphism
    -Compile-time / early binding / static binding   BEFORE THE PROGRAM EXECUTES
    -Run-time     / late binding  / dynamic binding  AS THE PROGRAM EXECUTES 
.In C++, default is compile-time
.Runtime Polymorphism
    -Being able to assign different meanings to the same function at run-time
.Allows us to program more abstractly
    -General vs Specific
    -Let C++ figure out which function to call at runtime
.Not the default in C++, runtime polymorphism is achieved via:
    -Inheritance
    -Base class pointers or references
    -Virtual functions 
--------------------------------------
                            Polymorphism
                            /          \
                    Compile-time       Run-time
                        |                  |                  
                    ---------              \/
                    |        |          Function Overriding 
                    |        \/
    Function Overloading    Operator Overloading
---------------------------------------
Non-polymorphic example with Static Binding:

Account a;
a.withdraw(1000);            // Account::withdraw()

Savings b;
b.withdraw(1000);            // Savings::withdraw()

Checking c;
c.withdraw(1000);            // Checking::withdraw()

Trust d;
d.withdraw(1000);            // Trust::withdraw()

Account *p = new Trust();     
p->withdraw(1000);           // Account::withdraw(), but SHOULD BE Trust::withdraw()
-----------------------------------------
Static Binding:

void display_account(const Account &account){
    acc.display();   // will always use Account::display()
}

Account a;
display_account(a);     // Account::display_account(a)
Savings b;
display_account(b);     // Account::display_account(b)
Checking c;
display_account(c);     // Account::display_account(c)
Trust d;
display_account(d);     // Account::display_account(d)
-------------------------------------------
Dynamic Binding:

Account a;
a.withdraw(1000);            // Account::withdraw()

Savings b;
b.withdraw(1000);            // Savings::withdraw()

Checking c;
c.withdraw(1000);            // Checking::withdraw()

Trust d;
d.withdraw(1000);            // Trust::withdraw()

Account *p = new Trust();    // USING POLYMORPHISM:
p->withdraw(1000);           // Trust::withdraw()

    Account::withdraw()
            /\
            |
 ------------------------
 |                      |
Savings::withdraw()   Checking::withdraw()
      /\                                   // withdraw() method is virtual in Account
      |
  Trust::withdraw()

---------------------------------------------------------------------------------------
Using Base Class Pointers:

.For dynamic polymorphism, we must have:
    -Inheritance
    -Base class pointer or Base class reference
    -Virtual functions

Account *p1 = new Account();
Account *p2 = new Savings();
Account *p3 = new Checking();
Account *p4 = new Trust();

p1->withdraw(1000);    // Account::withdraw(1000);
p2->withdraw(1000);    // Savings::withdraw(1000);
p3->withdraw(1000);    // Checking::withdraw(1000);
p4->withdraw(1000);    // Trust::withdraw(1000);

Account *array[] = {p1,p2,p3,p4};

for (auto i=0; i<4; i++){
    array[i]->withdraw(1000);  // calls specific version of withdraw
}

vector<Account *> accounts {p1,p2,p3,p4};

for (auto acc_ptr : accounts) {
    acc_ptr->withdraw();       // calls specific version of withdraw
}

// delete the pointers 
---------------------------------------------------------------------------------------
Virtual Functions:

.Redefined functions are bound statically
.Overriden functions are bound dynamically
.We accomplish this by declaring the functions to be virtual; virtual objects
are overriden
.Allows us to treat all objects generally as objects of the Base class 

.Declare the function you want to override as virtual in the Base class
.Virtual functions are virtual all the way down the hierarchy from this point
.Dynamic polymorphism only via Account class pointer or reference

class Account {
public:
    virtual void withdraw(double amount);
    ...
};
------------------------------------------
.Override the function in the Derived classes
.Function signature and return type must match EXACTLY
.Virtual keyword not required but is best practice
.If you don't provide an overriden version, it is inherited from its base class

class Checking : public Account {
public:
    virtual void withdraw(double amount);
    ...
};







.Virtual destructors
.The OVERRIDE and FINAL specifiers
.Using base class references
.Pure virtual functions and abstract classes
.Abstract classes as interfaces 