--------------------------- Polymorphism -------------------------------------
What is polymorphism?

.Fundamental to Object-Oriented Programming
.Polymorphism
    -Compile-time / early binding / static binding   BEFORE THE PROGRAM EXECUTES
    -Run-time     / late binding  / dynamic binding  AS THE PROGRAM EXECUTES 
.In C++, default is compile-time
.Runtime Polymorphism
    -Being able to assign different meanings to the same function at run-time
.Allows us to program more abstractly
    -General vs Specific
    -Let C++ figure out which function to call at runtime
.Not the default in C++, runtime polymorphism is achieved via:
    -Inheritance
    -Base class pointers or references
    -Virtual functions 
--------------------------------------
                            Polymorphism
                            /          \
                    Compile-time       Run-time
                        |                  |                  
                    ---------              \/
                    |        |          Function Overriding 
                    |        \/
    Function Overloading    Operator Overloading
---------------------------------------
Non-polymorphic example with Static Binding:

Account a;
a.withdraw(1000);            // Account::withdraw()

Savings b;
b.withdraw(1000);            // Savings::withdraw()

Checking c;
c.withdraw(1000);            // Checking::withdraw()

Trust d;
d.withdraw(1000);            // Trust::withdraw()

Account *p = new Trust();     
p->withdraw(1000);           // Account::withdraw(), but SHOULD BE Trust::withdraw()
-----------------------------------------
Static Binding:

void display_account(const Account &account){
    acc.display();   // will always use Account::display()
}

Account a;
display_account(a);     // Account::display_account(a)
Savings b;
display_account(b);     // Account::display_account(b)
Checking c;
display_account(c);     // Account::display_account(c)
Trust d;
display_account(d);     // Account::display_account(d)
-------------------------------------------
Dynamic Binding:

Account a;
a.withdraw(1000);            // Account::withdraw()

Savings b;
b.withdraw(1000);            // Savings::withdraw()

Checking c;
c.withdraw(1000);            // Checking::withdraw()

Trust d;
d.withdraw(1000);            // Trust::withdraw()

Account *p = new Trust();    // USING POLYMORPHISM:
p->withdraw(1000);           // Trust::withdraw()

    Account::withdraw()
            /\
            |
 ------------------------
 |                      |
Savings::withdraw()   Checking::withdraw()
      /\                                   // withdraw() method is virtual in Account
      |
  Trust::withdraw()

---------------------------------------------------------------------------------------
Using Base Class Pointers:

.For dynamic polymorphism, we must have:
    -Inheritance
    -Base class pointer or Base class reference
    -Virtual functions

Account *p1 = new Account();
Account *p2 = new Savings();
Account *p3 = new Checking();
Account *p4 = new Trust();

p1->withdraw(1000);    // Account::withdraw(1000);
p2->withdraw(1000);    // Savings::withdraw(1000);
p3->withdraw(1000);    // Checking::withdraw(1000);
p4->withdraw(1000);    // Trust::withdraw(1000);

Account *array[] = {p1,p2,p3,p4};

for (auto i=0; i<4; i++){
    array[i]->withdraw(1000);  // calls specific version of withdraw
}

vector<Account *> accounts {p1,p2,p3,p4};

for (auto acc_ptr : accounts) {
    acc_ptr->withdraw();       // calls specific version of withdraw
}

// delete the pointers 
---------------------------------------------------------------------------------------
Static vs. Dynamic Binding:




.Virtual functions
.Virtual destructors
.The OVERRIDE and FINAL specifiers
.Using base class references
.Pure virtual functions and abstract classes
.Abstract classes as interfaces 